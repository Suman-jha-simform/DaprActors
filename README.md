# Dapr Actors

An actor is a self-contained unit of code that receives messages and processes them one at a time, without any kind of concurrency or threading. ​Dapr implements the `Virtual Actor pattern`, which provides a framework for writing actors that can be activated and deactivated dynamically based on demand. ​Dapr underlying runtime oversees the execution of each actor, determining how, when, and where they operate, while also facilitating message routing between actors.


## Actor Types and Actor IDs
Actors are defined as the `instance` of an actor type and identified by an `actor id`. The `actor id` can be an string value we choose or if not choosen it is dynamically generated by Dapr.

## Actor Features

### Namespaced actors
Dapr support namespaced actors meaning actors can be deployed in different `namespaces` and it's `instance` can be referenced in the same `namespace`.

### Actor lifetime 
Dapr actors are `virtual`, meaning they don't need to be explicitly created or destroyed.​ The Dapr actor runtime automatically activates an actor when it receives an initial request for that actor ID.​ The unused actors are `garbage-collected` by the runtime, while the runtime maintains knowledge of the actor's existence for potential future activation.​  

### Actor State Management
Actors can store their state using a `transactional state store` compatible with Dapr. The state is stored using a combination of the `application ID`, `actor type`, `actor ID`, and the `state key`.​ In order to retrieve actor state, we can use the Dapr State Management API. The actor state is stored in a specific scheme in the transactional state store, allowing for consistent querying.​

### Actor Communication​
Actors communicate by sending messages to each other.​ While processing a message, an actor can invoke methods on other actors or create new actors identified by a unique `actor ID` within their `actor type​`. We can interact with Dapr to invoke the actor method by calling `HTTP/gRPC` endpoint.

Example :
* The service calls the `actor API` on the sidecar.
* With the cached partitioning information from the placement service, the sidecar determines which actor service instance will host `actor ID 3`. The call is forwarded to the appropriate sidecar.
* The sidecar instance in `pod 2` calls the service instance to invoke the actor and execute the actor method.

![image](https://github.com/user-attachments/assets/1c8aac46-2f93-4662-9178-a08e3f3c9d0a)


### Actor Timers and Reminders
Dapr actors can utilize timers and reminders to schedule periodic tasks.​ `Timers` are stateless and execute only while the actor is active.​`Reminders` are stateful, persisted by the runtime, and can rehydrate the actor to execute even after deactivation.

### Actor Concurrency and Turn-based Access​
The Dapr actor runtime provides a simple `turn-based access model` for accessing actor methods. Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.​ A single actor instance cannot process more than one request at a time. An actor instance can cause a throughput `bottleneck` if it is expected to handle concurrent requests.

## Dapr Actor Use Cases
* If problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.​
* If you want to work with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.​
* If  actor instances won’t block callers with unpredictable delays by issuing I/O operations.​


## Dapr Demo

### Prerequisites 
- [Docker Desktop](https://www.docker.com/products/docker-desktop/) for running images.
- [Dapr CLI](https://docs.dapr.io/getting-started/install-dapr-cli/) for running dapr sidecar.
- [Postman] (https://www.postman.com/) for testing.

### Steps for Setup 

1. Install all the prerequisites.
2. Run the `Docker Desktop`
3. Open `CMD` as `Admin` and navigate to your `..\DemoActors\DemoActors` directory.
4. Run the command `dapr init`.
   ```bash
   dapr init
   ```

![image](https://github.com/user-attachments/assets/e4f3750e-e2af-4728-aadb-b4381a7adb8d)


5. Open `Docker Desktop` and check if the images are in `running` state if not , select all and click on `play` button to run them.


![image](https://github.com/user-attachments/assets/04f3b759-df3d-4c6c-916c-087cddc85e39)

6. Now run the command given below, this command runs the dapr on port 3500
 
```bash
dapr run --app-id demoactors --resources-path ../components --app-port 5271 --dapr-http-port 3500 -- dotnet run
```

![image](https://github.com/user-attachments/assets/027e83c1-104f-4d9f-b3f1-8d6051097421)
![image](https://github.com/user-attachments/assets/9c18e991-36de-4bfc-9393-26e0055570e1)

7. You can check further details by opening the dapr dashboard. Run the command on `CMD` with `admin` privileges.
   
```bash
dapr dashboard
```

## Basic Actor Samples
The `DemoActors` folder contains number of sample actors which are written in `c#` and uses the Dapr Actors `.NET SDK`.
The Actor performs interaction using the `Postman` and uses 'Redis' for its state management.

#### Shopping Cart Actor
The `ShoppingCartActor` is a stateful actor and contains three methods, `AddItemAsync` , `RemoveItemAsync`, `GetItemAsync` to add,remove and get items from the cart.

The `AddItemAsync` method with `Laptop` item:
```bash
http://localhost:3500/v1.0/actors/ShoppingCartActor/123/method/AddItemAsync
```

![image](https://github.com/user-attachments/assets/c46cb4c9-0086-4fb5-a657-2e095b614b82)


The `GetItemAsync` method:
```bash
http://localhost:3500/v1.0/actors/ShoppingCartActor/123/method/GetItemAsync
```
![image](https://github.com/user-attachments/assets/17e38eec-d0d0-4cee-9dcc-5debd43024b5)

![image](https://github.com/user-attachments/assets/2dcf1241-8d25-42e7-9937-a11593e51456)


The `RemoveItemAsync` method with `Laptop` item will delete this item from the cart:
```bash
http://localhost:3500/v1.0/actors/ShoppingCartActor/123/method/RemoveItemAsync
```
![image](https://github.com/user-attachments/assets/486a4b93-df3f-4b04-9498-1218e9eb75eb)



#### Timer Actor
The `TimerActor` contains the timer which after a fixed duration executes the handler method it is pointing to.
The timer is stateless in nature , meaning once stopped the actor becomes inactive and can no longer be called.

The `StartTimerAsync` method creates the timer :
```bash
http://localhost:3500/v1.0/actors/TimerActor/123/method/StartTimerAsync
```
![image](https://github.com/user-attachments/assets/af3d43df-0579-4684-8e3a-6356344bcb4b)



The `GetLastTimerOutputAsync` method gets the state value after the callback method is called at an interval of `5 seconds`:
```bash
http://localhost:3500/v1.0/actors/TimerActor/123/method/GetLastTimerOutputAsync
```
![image](https://github.com/user-attachments/assets/c26807bd-f646-419d-98b9-5729ee3e2c6e)
![image](https://github.com/user-attachments/assets/03816b60-7b8f-42bf-9239-6610fdde4163)

After some duration if ytou execute the `API` call once again you will the state value being incremented.

![image](https://github.com/user-attachments/assets/dfd83b36-a2ee-4a3f-a1c0-a4e85f606773)


The `StopTimerAsync` method stops the timer:
```bash
http://localhost:3500/v1.0/actors/TimerActor/123/method/StopTimerAsync
```
![image](https://github.com/user-attachments/assets/3cabee04-eda8-4079-b84f-73b629061b3b)

Now the value of timer will not change even if you execute the `GetLastTimerOutputAsync` multiple times.

#### Reminder Actor
The `ReminderActor` contains the reminder which is stateful in nature i.e even after termination the actor can be referenced.

The `StartReminderAsync` method creates the reminder :
```bash
http://localhost:3500/v1.0/actors/ReminderActor/123/method/StartReminderAsync
```
![image](https://github.com/user-attachments/assets/290b91f5-d423-4220-a67e-9018159c9fb9)


The `ReminderCallback` method sets the state value after the interval of `5 seconds`:
```bash
http://localhost:3500/v1.0/actors/ReminderActor/123/method/ReminderCallback
```
![image](https://github.com/user-attachments/assets/4b662d3c-fd28-43d7-9bd2-4990c01f762d)


The `GetReminderOutput` method gets the state value after the callback method is called at an interval of `5 seconds`:
```bash
http://localhost:3500/v1.0/actors/ReminderActor/123/method/GetReminderOutput
```
![image](https://github.com/user-attachments/assets/1394a1e9-53e8-4417-b3ec-9dfb4be537df)

![image](https://github.com/user-attachments/assets/360f50ba-4d5f-4610-8932-ad4e02dd3e60)

The `StopTimerAsync` method stops the reminder:
```bash
http://localhost:3500/v1.0/actors/ReminderActor/123/method/StopReminderAsync
```

![image](https://github.com/user-attachments/assets/3f98bd3c-eabc-430e-9f4a-efb1e4100a73)

After stopping the timer, you can still execute the method `ReminderCallback` and it increases the state value which can be validated using `GetReminderOutput` method call. This shows that `Reminders` are stateful in nature.



## References 
- [Dapr Actors Overview](https://docs.dapr.io/developing-applications/building-blocks/actors/actors-overview/)
- [Dapr Actors API](https://docs.dapr.io/reference/api/actors_api/)







